model.property.error.message=Cannot resolve property ''{0}''
model.create.factory.method.quickfix.message=Create factory method ''{0}''
model.create.factory.method.quickfix.family.name=Create factory method
model.add.constructor.args.for.method.quickfix.message=Add <constructor-arg>(s) for ''{0}''
model.add.constructor.args.for.method.quickfix.message.family.name=Add <constructor-arg>(s)

model.bean.quickfix.message=Create new bean ''{0}''
model.bean.quickfix.message.family.name=Create new bean

model.inspection.display.name=Spring Model
model.inspection.display.bean.name.convention=Spring Bean Names Convention
model.inspection.bean.property.value=Injection Value Type
model.inspection.bean.constructor.arg=Constructor Tag Injection
model.inspection.bean.autowiring=Spring Bean Autowiring
model.inspection.bean.dependency.check=Spring Bean Dependency Check
model.inspection.validator.progress.text=Validating Spring Model...

scopes.inspection.display.name=Spring Scopes

inspection.group.code=Code
inspection.group.setup=Setup
inspection.group.xml=XML

model.inspection.invalid.identifier.message=''{0}'' does not follow bean naming convention
model.inspection.invalid.lowercase.name.message=''{0}'' should start with lowercase letter

model.inspection.bean.factory.method=Spring Bean Factory Method
model.inspection.bean.public.factory.method=Spring Bean Public Factory Method
method.must.be.static=Factory method ''{0}'' must be static
method.must.not.be.static=Factory method ''{0}'' must not be static
method.must.be.public=Factory method ''{0}'' should be public
method.cannot.instantiate.bean=Factory method ''{0}'' cannot instantiate bean

bean.dependency.check.message=You must set bean properties({0}) or disable dependency checking for this bean

bean.autowiring.by.type.none=Could not autowire. No beans of ''{0}'' type found.
bean.autowiring.by.type.no.beans=Could not autowire. No beans of ''{0}'' or ''{1}'' types found.
bean.autowiring.by.type=Could not autowire. There is more than one bean of ''{0}'' type. Beans: {1}. Properties: ''{2}''
bean.class.autowired.by.type=Could not autowire. There is more than one bean of ''{0}'' type.
bean.autowiring.by.type.no.parameter.for.autowired.method= Autowired {0} without parameters
bean.class.autowired.incorrect.qualifier.type=Could not autowire. Qualified bean must be of ''{0}'' type.
bean.class.unknown.qualifier.bean=Cannot find bean with qualifier ''{0}''

bean.must.be.public=Bean must be public
bean.bad.property.type=Property of ''{0}'' type cannot be injected by ''{1}''
idref.cannot.be.added.in.collection=Cannot be added in collection of ''{0}'' type
timeout.parsing.bean=Custom bean parsing took too long
process.unexpectedly.terminated=Process unexpectedly terminated{0}
try.parsing.custom.beans=Try parsing custom beans

cannot.find.bean.constructor.with.parameters.count=No matching constructor found in class ''{0}''
cannot.find.factory.method.with.parameters.count=No matching factory method found in class

cannot.find.constructor.arg.index=Cannot find constructor with argument index {0}
cannot.find.constructor.arg.index.in.class=Cannot find constructor with argument index {0} in class {1}
cannot.find.factory.method.index=Cannot find factory method with argument index {0} in class {1}

incorrect.constructor.arg.index.not.unique=Index must be unique
constructor.arg.incorrect.value.type=Injected value type must correspond to constructor arg type

spring.bean=Spring Bean
spring.property=Spring Property
spring=Spring

config.display.name=Configuration
config.no.contexts.defined=No application contexts defined

spring.beans.dependencies=Dependencies

spring.bean.class.tooltip.navigate.declaration=Navigate to the spring bean declaration(s)
navigate.to.autowired.dependencies=Navigate to the autowired dependencies
navigate.to.by.name.autowired.dependencies=Navigate to 'byName' autowired dependencies

spring.bean.show.beans.candidates.title=Bean candidates

gutter.navigate.no.matching.beans=No matching beans found
spring.bean.class.navigate.choose.class.title=Choose Bean
spring.bean.property.tooltip.navigate.declaration=Navigate to the spring bean property
spring.bean.property.navigate.choose.class.title=Choose Bean Containing The Property
spring.bean.constructor.tooltip.navigate.declaration=Navigate to the spring bean
spring.bean.constructor.navigate.choose.class.title=Choose Bean Containing The Constructor
spring.bean.methods.tooltip.navigate.declaration=Navigate to the spring bean method declarations
spring.bean.method.tooltip.navigate.declaration=Navigate to the spring bean {0} method declaration

config.file.not.found=File not found
config.file.is.not.spring=The file is not recognized as Spring configuration
spring.bean.lookup.method.inspection=Lookup Method
spring.bean.lookup.method.incorrect.return.type=Incorrect lookup method return type
spring.bean.lookup.method.constructor.not.allowed=Constructor is not allowed here
spring.bean.lookup.method.return.type.mismatch=Lookup method return type does not match the ''{0}'' bean class
spring.bean.lookup.method.bean.has.no.class='{0}' bean has no class
spring.bean.lookup.method.must.be.public.or.protected=Method must be public or protected
spring.bean.lookup.method.must.have.no.parameters=Method must have no parameters
spring.bean.lookup.method.must.be.not.static=Static method not allowed here

model.inspection.injection.value.style=Spring Injection Value Style
model.inspection.injection.value.style.message=Usage of explicit <value> element
model.inspection.injection.value.style.value.fix=Replace <value> element with "{0}" attribute
model.inspection.injection.value.style.value.fix.family.name=Replace <value> element with attribute
model.inspection.injection.value.style.ref.fix=Replace <ref> element with "{0}" attribute
model.inspection.injection.value.style.ref.fix.family.name=Replace <ref> element with attribute
model.inspection.injection.value.style.ref.message=Usage of explicit <ref> element

model.intention.string.constant.move.to.placeholder=Move to placeholder

spring.bean.property=Property
spring.bean.constructor.arg=Constructor argument
spring.bean.map.entry=Map entry

model.inspection.injection.value.consistency=Injection Value Consistency
model.inspection.injection.value.message={0} must specify a ref or value
spring.bean.property.value.inconsistency.ref.or.value.sub.element.must.defined={0} is only allowed to contain either "ref" attribute OR "value" attribute OR sub-element
spring.bean.property.value.inconsistency.more.one.sub.element ={0} must not contain more than one sub-element
spring.bean.ref.attributes.inconsistency=<ref> tag is only allowed to contain either "bean" attribute OR "local" attribute OR "parent" attribute
spring.bean.ref.attributes.must.specify=<ref> tag must specify a bean
spring.bean.idref.attributes.inconsistency=<idref> tag is only allowed to contain either "bean" attribute OR "local" attribute
spring.bean.idref.attributes.must.specify=<idref> tag must specify a bean
model.inspection.injection.value.entry.key=Map entry must specify a key
spring.bean.property.value.inconsistency.key=Map entry is only allowed to contain either "key" attribute OR "key-ref" attribute OR <key> sub-element

model.inspection.injection.value.add.ref=Add "ref" attribute
model.inspection.injection.value.add.list=Add <list> tag
model.inspection.injection.value.add.set=Add <set> tag
model.inspection.injection.value.add.array=Add <array> tag
model.inspection.injection.value.add.map=Add <map> tag


spring.bean.abstract.bean.references.inspection=Abstract Beans References
spring.bean.referenced.by.abstract.bean=Abstract bean cannot be used here
      
spring.bean.autowire.escape.inspection.name=Autowired Dependencies
spring.bean.use.autowire=Unnecessary use of autowired dependencies
spring.bean.autowire.escape=Make autowired dependencies explicit

spring.bean.duplicated.bean.name.inspection=Duplicate Bean Name
spring.bean.duplicate.bean.name=Bean name duplicated

spring.bean.instantiation.by.factory=Spring Bean (instantiated by a factory bean)
spring.bean.instantiation.using.factory.method=Spring Bean (instantiated by a static factory method)
spring.import=Import
spring.generate.properties=Properties...
spring.generate.setter.dependencies=Setter Dependency...
spring.generate.constructor.dependencies=Constructor Dependency...
action.Spring.Beans.Generate.Setter.Dependency.Action.text=Spring Setter Dependency...
action.Spring.Beans.Generate.Constructor.Dependency.Action.text=Spring Constructor Dependency...
spring.bean.properties.chooser.title=Choose Properties
spring.bean.dependencies.chooser.title=Choose Bean
spring.beans.chooser.show.context.files=Show context files
spring.beans.chooser.all.context.files=All beans
spring.beans=Beans
show.properties.and.constructor.args=Show properties and constructor arguments
util.schema.inspection.name=Util Schema
util.required.class.message=Class must be inheritor of ''{0}''

spring.bean.instantiation.inspection=Spring Bean Instantiation
mark.bean.as.abstract=Mark bean as abstract
abstract.class.not.allowed=Abstract class not allowed for non-abstract beans
interface.not.allowed=Interface not allowed for non-abstract beans

spring.parent.bean.tooltip=Navigate to the child declarations

spring.template.beans=Template Beans

spring.patterns=Frameworks/Technologies
spring.patterns.hibernate=Hibernate
spring.patterns.jdo=JDO
spring.patterns.toplink=Toplink
spring.patterns.ibatis=iBatis
spring.patterns.quartz.scheduler=OpenSymphony Scheduler
spring.patterns.jdk.timer=JDK Timer

spring.patterns.aop.group.name=Aop
spring.patterns.data.access.group.name=Data Access
spring.patterns.integration.group.name=Integration
spring.patterns.scheduling.group.name=Scheduling
spring.patterns.common.beans.group.name=Common Beans
spring.patterns.data.access.hibernate.session.factory=Hibernate Session Factory
spring.patterns.data.access.hibernate.transaction.manager=Hibernate Transaction Manager

spring.patterns.data.access.jdo.persistence.manager=JDO Persistence Manager Factory
spring.patterns.data.access.jdo.jpox.persistence.manager=JPOX Persistence Manager  Factory
spring.patterns.data.access.jdo.persistence.manager.proxy=JDO Persistence Manager Proxy
spring.patterns.data.access.jdo.transaction.manager=JDO Transaction Manager

spring.patterns.data.access.toplink.session.factory=Toplink Session Factory
spring.patterns.data.access.toplink.transaction.aware.session.adapter=Toplink Transaction Aware Session Adapter
spring.patterns.data.access.toplink.transaction.manager=Toplink Transaction Manager
spring.patterns.data.access.ibatis.client.factory=iBatis SqlMapClient Factory

spring.patterns.data.access.data.source=Data Source
spring.patterns.data.access.jndi.data.source=Jndi Data Source
spring.patterns.data.access.transaction.manager=Transaction Manager

spring.patterns.aop.auto.proxy.creator=AspectJ Auto Proxy Creator
spring.patterns.aop.auto.proxy=Aop: AspectJ Auto Proxy

spring.patterns.integration.opensymphony.job.detail.bean=OpenSymphony Job Detail Bean
spring.patterns.integration.opensymphony.method.invoking.factory.bean=OpenSymphony Method Invoking Factory
spring.patterns.integration.opensymphony.simple.trigger=OpenSymphony Simple Trigger
spring.patterns.integration.opensymphony.cron.trigger=OpenSymphony Cron Trigger
spring.patterns.integration.opensymphony.scheduler=OpenSymphony Scheduler Factory Bean

spring.patterns.integration.jdk.scheduled.timer.task=JDK scheduled timer task
spring.patterns.integration.jdk.timer.factory.bean=JDK Timer Factory Bean
spring.patterns.integration.jdk.method.invoking.factory.bean=JDK Method Invoking Timer Task Factory

spring.patterns.integration.ejb.local.stateless.session.bean=EJB Local Stateless Session Bean
spring.patterns.integration.ejb.remote.stateless.session.bean=EJB Remote Stateless Session Bean
spring.patterns.integration.free.marker.factory.bean=Free Marker Configuration Factory Bean

spring.patterns.common.beans.placeholder=Property Placeholder Configurer
spring.patterns.common.beans.property.override.configurer=Property Override Configurer
spring.patterns.factory.beans.resource=Resource Factory Bean
spring.patterns.factory.beans.commons.log=Commons Log Factory Bean
spring.patterns.factory.beans.set=Set Factory Bean
spring.patterns.factory.beans.list=List Factory Bean
spring.patterns.factory.beans.map=Map Factory Bean
spring.patterns.factory.beans.properties=Properties Factory Bean
spring.patterns.factory.beans.field.retrieving=Field Retrieving Factory Bean

spring.choose.bean.templates.dialog.title=Add {0} Beans

facet.context.default.name=Spring Application Context

facet.context.xml.files=XML-based configurations
facet.context.code.files=Code-based configurations
facet.context.properties.files=Additional properties files
facet.context.other.files=Other files
facet.context.autodetected.suffix= (autodetected)
facet.context.autoconfigured.suffix= (autoconfigured)

facet.context.new.title=New Application Context
facet.context.edit.title=Edit Application Context ''{0}''
facet.context.edit.name.label=&Name\:
facet.context.edit.parent.label=&Parent context\:
facet.context.edit.parent.none.selected=<none>
facet.context.edit.name.validation.not.empty=Name must not be empty
facet.context.edit.name.validation.already.exists=Context with such name already exists. If you deleted existing context with such name, you must use "Apply" first.
facet.context.edit.add.file.choose.type=Choose Type

facet.context.remove.title=Remove
facet.context.remove.message=Do you really want to remove application context "{0}"? (No files will be deleted)

config.new.file=Spring Config
config.new.file.name=&File name:
config.new.file.directory=&Directory:
create.new.spring.configuration.file=Create new Spring configuration file

spring.java.configuration.inspection.cannot.find.external.bean=Cannot find external bean
spring.java.configuration.inspection.class.type.expected=Class type expected
spring.java.configuration.inspection.incorrect.return.type.of.external.bean=Incorrect return type. {0} is expected

spring.java.configuration.inconsistency.inspection.name=Java Config
spring.java.configuration.inspection.name=Java Configured @ExternalBean

framework.title.spring=&Spring

spring.facet.inspection=Spring Facet XML Configuration
spring.facet.code.inspection=Spring Facet Code Configuration
spring.facet.programmatic.inspection=Spring Facet Programmatic Configuration

spring.facet.inspection.create.facet=Create Spring facet
spring.facet.inspection.context.choose=Choose Application Context
spring.facet.inspection.context.create=Create new application context...
spring.facet.inspection.context.not.configured.for.file=Application context not configured for this file
spring.facet.inspection.configure.context.for.file=Configure application context
spring.facet.inspection.check.test.files=Check test files

introduce.bean.intention=Introduce bean

parse.custom.bean.intention=Parse custom bean
parsing.custom.bean=Running custom Spring bean handlers...
parse.custom.bean.error=Error Parsing Custom Bean
parse.custom.bean.success=Custom Handler Has Finished Successfully
parse.no.custom.beans=Parser produced no beans
parse.only.infrastructure.beans=Parser produced only infrastructure beans
parse.these.beans=Custom namespace handler produced the following bean definitions:\n{0}
parse.these.beans.induct=Custom namespace handler produced the following bean definition:\n{0}\n\n\
  Do you want to assume that all beans \n\
  from namespace ''{1}'' with local name ''{2}''\n\
  have the same class and take their id from ''{3}'' attribute?
parse.these.beans.induct.only.this=&No, only this bean
parse.no.namespace.handler=Cannot find custom handler for namespace ''{0}''
unparsed.custom.bean.inspection=Unparsed custom Spring beans
unparsed.custom.bean.message=This custom Spring bean has not yet been parsed
custom.bean.no.id=IntelliJ IDEA can't find this bean's id in config file. Renaming will probably produce\nincorrect code. Do you want to proceed?
custom.bean.no.id.title=Warning

spring.refactoring=Spring Refactorings
do.you.want.to.move.bean.to.the.top.level=Do you want to move the bean to the top level?
move.bean.to.the.top.level=Move Bean To the Top Level
move.bean=Move Bean
update.schema.intention=Convert to Spring XML schema
use.p.namespace=Convert to p-namespace
xml.schema.will.be.updated=XML schema will be updated to spring-beans.xsd. \nDo you want to proceed?
xml.schema.update.is.required=XML Schema Update Is Required

model.qualifiers.in.class.inspection.display.name=Autowiring for Bean Class
java.class.construcor.autowirig.inspection.display.name= Autowiring issues in a spring bean class constructors
required.properties.inspection=Required Annotation
required.property.not.mapped=Required property ''{0}'' is not injected
create.missing.mappings=Create missing mappings for ''{0}''
create.missing.mappings.family.name=Create missing mappings

spring.required.property.inspection=Required Properties
required.properties.missed=Required properties missing: ''{0}''
create.missing.properties=Create missing properties
cannot.find.bean.qualified.by=Cannot find bean qualified with {0}
cannot.autowire.bean.of.type=Could not autowire. Bean should be of ''{0}'' type
java.configuration.cannot.be.final=@Configuration class may not be final
java.configuration.must.have.default.constructor=Configuration classes must have a default/no-arg constructor
java.configuration.autowired.constructor.param=@Configuration class may not use autowired constructor
java.config.bean.method.cannot.return.void=@Bean methods must be non-void
java.config.bean.method.cannot.be.final=@Bean methods must be non-final
java.config.bean.method.cannot.be.private==@Bean methods must be non-private
java.config.bean.method.cannot.has.arguments=@Bean methods may not accept any arguments
java.config.bean.must.be.declared.inside.configuration=@Bean methods are valid only when declared within a @Configuration annotated class
required.spring.bean.type.inspection=Required Bean Type
placeholders.inspection.display.name=Spring Placeholders

spring.incorrect.resource.type.inspection=Incorrect Resource Type
SpringIncorrectResourceTypeInspection.incorrect.resource.type=Incorrect resource type
SpringIncorrectResourceTypeInspection.expected.resource.types=Incorrect resource type. Expected types: {0}
spring.import.resource.inspection.display.name=@ImportResource location warnings
spring.property.source.inspection.display.name=@PropertySource and @TestPropertySource location warnings
spring.configuration.proxy.methods.display.name=@Configuration proxyMethods usage warnings
spring.context.configuration.inspection.display.name=@ContextConfiguration and @SqlConfig warnings
spring.testing.sql.inspection.display.name=@Sql and @SqlGroup warnings
spring.transaction.inspection.display.name=Undefined PlatformTransactionManager
spring.lookup.inspection.display.name=@Lookup
SpringContextConfigurationInspection.cannot.find.default.app.context=Cannot find default application context file {0}
SpringContextConfigurationInspection.create.nested.configuration.class=Create nested ContextConfiguration class
action.generate.autowired.dependencies.action.text=@Autowired Dependency...
SpringAutowiringInspection.add.qualifier.fix=Add qualifier
context.schema.inspection.name=Context Component Scan
ContextComponentScanInconsistencyInspection.annotation.is.expected.here=Annotation is expected here

editor.panel.profiles.tooltip=Active Profile
editor.panel.profiles.tooltip.action.name=Change Profiles...

SpringInactiveProfilesHighlightingPass.inactive.profile=Inactive profile
spring.dom.component.scan.stereotypes=Choose Stereotype
spring.dom.component.scan.stereotypes.title=Navigate to components
ContextJavaBeanUnresolvedMethodsInspection.display.name=@Configuration and @Bean
ContextJavaBeanUnresolvedMethodsInspection.cannot.resolve.method=Cannot resolve method


ActivateSpringProfileIntentionAction.activate.profile=Activate profile ''{0}''
ActivateSpringProfileIntentionAction.activate.profile.family.name=Activate profile

spring.app.context.to.navigate=Choose Application Context
spring.app.context.navigate.tooltip=Navigate to Application Context

SpringStaticMembersAutowiringInspection.display.name=Static Members Autowiring
static.members.autowiring=Don't autowire static members

gutter.choose.autowired.candidates.title=Choose Autowired Candidate
gutter.navigate.to.autowired.candidates.title=Navigate to autowired candidates
gutter.navigate.no.matching.autowired.candidates=No matching autowired candidates found
process.explicitly.annotated.beans=Process explicitly annotated beans
configuration.tab.additional.settings=Additional settings

multiple.context.tooltip.text=Active Context
multiple.context.description.in.module.text=<html><body>  in module <b>{0}</b>.</body></html>
multiple.context.description.label.text=<html><body>File is included in <b>{0} contexts</b>.</body></html>
multiple.context.description.in.modules.label.text=<html><body>File is included in <b>{0} contexts</b> in <b>{1}</b> modules.</body></html>
class.without.matching.constructor.for.autowiring=Class doesn't contain matching constructor for autowiring
multiple.autowiring.constructor=Only one constructor can have @Autowired annotation
springAutowiredMembersInspection.inspection=Autowired members defined in invalid Spring bean
class.is.not.spring.bean.autowired=Autowired members must be defined in valid Spring bean (@Component|@Service|...)

model.inspection.inactive.profile=Inactive profile highlighting

local.model.dependencies.diagram.title=Spring Model Dependencies
gutter.dependencies.diagram.merged.action.title= Spring Diagrams...

spring.event.publisher.choose.title=Choose Event Publisher
spring.event.publisher.tooltip.text=Go to Event Publisher

spring.event.listener.choose.title=Choose Event Listener
spring.event.listener.tooltip.text=Go to Event Listener
spring.cacheable.annotations.inspection.display.name=@Cacheable, @CacheEvict, @CachePut, @CacheConfig errors
spring.cacheable.names.inspection.display.name=Cache names definition errors
spring.cacheable.and.cache.put.on.the.same.method.display.name=Using @CachePut and @Cacheable on same method

spring.cacheable.annotations.on.interfaces=Cache* annotations defined on interfaces/interface methods
cacheable.annotations.should.be.defined.on.public.methods=Caching annotations should be defined on public methods
cacheable.no.cache.could.be.resolved.for.cache.operation= At least one non empty cache name should be provided per cache operation.
cacheable.should.be.defined.on.concrete.method=Spring doesn't recommend to annotate interface methods with @Cache* annotation
cacheable.and.cache.put.on.the.same.method=Spring doesn't recommend to use @CachePut and @Cacheable annotate on the same method
event.listener.method.parameters.count=Method must have maximum one parameter
event.listener.method.visibility.public=Method annotated with @EventListener must be public
event.listener.method.visibility.nonstatic=Method annotated with @EventListener must be non-static

spring.cacheable.element.choose.title=Choose Cacheable Operation
spring.cacheable.element.tooltip.text=Go to Cacheable Operation With The Same Name

SpringAutowiredFieldsWarningInspection.inspection.display.name=Field injection warning
field.injection.is.not.recommended=Field injection is not recommended
field.injection.create.constructor.family.warning=Change field injection. Create constructor
field.injection.add.parameter.family.warning=Change field injection. Add parameter(s) to constructor
field.injection.create.constructor.injection=<html>Create constructor: {0}</html>
field.injection.add.parameters=<html>Add parameter(s) to constructor: {0}</html>
spring.testing.context.dirties.inspection.display.name=Spring Testing @DirtiesContext errors
spring.testing.transactional.inspection.display.name=Spring Testing @Transactional errors
spring.testing.model.dirties.method.mode.error.message=Setting the method mode on an annotated test class has no meaning.  For class-level control, use classMode instead.
spring.testing.model.dirties.class.mode.error.message=Setting the class mode on an annotated test method has no meaning. For method-level control use methodMode instead..
spring.testing.model.dirties.hierarchy.mode.error.message= hierarchyMode should be used when the context is configured as part of a hierarchy via @ContextHierarchy
spring.testing.transactional.wrong.number.of.arguments.error.message=Wrong number of arguments
spring.testing.transactional.void.method.return.type.error.message=Expected method return type is ''void''
ScheduledMethodInspection.inspection.display.name=Method annotated with @Scheduled should be void and no-args
method.parameters.removing.fix.family.name=Remove method parameters
method.parameters.removing.fix.text=Change ''{0}'' to no-arg
AsyncMethodInspection.inspection.display.name=Method annotated with @Async should return ''void'' or "Future-like" type
SpringEventListenerInspection.inspection.display.name=@EventListener configuration error
# suppress inspection "UnusedProperty"
method.return.type.make.async.family.name=Change method to return "Future-like" value
method.return.type.make.async.fix.text=Change method to return ''{0}''
ImplicitSubclassInspection.display.forClass.annotated=Classes annotated with ''@{0}'' could be implicitly subclassed and must not be final
ImplicitSubclassInspection.display.forMethod.annotated=Methods annotated with ''@{0}'' must be overridable
ImplicitSubclassInspection.display.bean.in.configuration=@Bean-method in @Configuration must be overridable
navigate.to.fileset.configuration=Navigate to application context configurations

bean.method.called.from.configuration.without.proxy=Method annotated with @Bean is called directly in a @Configuration where proxyBeanMethods set to false. Set proxyBeanMethods to true or use dependency injection.
bean.method.called.without.proxy=Method annotated with @Bean is called directly. Use dependency injection instead.